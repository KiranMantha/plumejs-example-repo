{"version":3,"file":"scripts/128.980359488067e2df12d4.bundle.js","mappings":"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","sources":["webpack:///./node_modules/@plumejs/router/dist/src/staticRouter.js","webpack:///./node_modules/@plumejs/router/dist/src/utils.js","webpack:///./node_modules/@plumejs/router/dist/src/internalRouter.service.js","webpack:///./node_modules/@plumejs/router/dist/src/router.component.js","webpack:///./node_modules/@plumejs/router/dist/src/router.service.js"],"sourcesContent":["export class StaticRouter {\n    static routeList = [];\n    static isHistoryBasedRouting = true;\n    static checkParams(urlParams, routeItem) {\n        let paramMapCount = 0;\n        const paramsObject = {}, paramCount = routeItem.paramCount;\n        for (let i = 0; i < urlParams.length; i++) {\n            const routeParam = routeItem.params[i];\n            if (routeParam.indexOf(':') >= 0) {\n                paramsObject[routeParam.split(':')[1]] = urlParams[i].split('?')[0];\n                paramMapCount += 1;\n            }\n        }\n        if (paramMapCount === paramCount) {\n            return paramsObject;\n        }\n        return {};\n    }\n    static getParamCount(params) {\n        let paramCount = 0;\n        params.forEach((param) => {\n            if (param.indexOf(':') >= 0) {\n                paramCount += 1;\n            }\n        });\n        return paramCount;\n    }\n    static formatRoute(route) {\n        const internalRouteItem = {\n            params: {},\n            url: '',\n            template: '',\n            paramCount: 0,\n            isRegistered: false,\n            redirectTo: '',\n            preload: route.preload,\n            canActivate: () => true\n        };\n        internalRouteItem.params = route.path.split('/').filter((str) => {\n            return str.length > 0;\n        });\n        internalRouteItem.url = route.path;\n        internalRouteItem.template = '';\n        internalRouteItem.redirectTo = route.redirectTo;\n        if (route.template) {\n            if (!route.templatePath)\n                throw Error('templatePath is required in route if template is mentioned.');\n            internalRouteItem.template = route.template;\n            internalRouteItem.templatePath = route.templatePath;\n        }\n        if (route.canActivate)\n            internalRouteItem.canActivate = route.canActivate;\n        internalRouteItem.paramCount = StaticRouter.getParamCount(internalRouteItem.params);\n        StaticRouter.routeList.push(internalRouteItem);\n    }\n    static preloadRoutes() {\n        for (const route of StaticRouter.routeList) {\n            route.templatePath && route.templatePath();\n        }\n    }\n    static preloadSelectedRoutes() {\n        const filteredRoutes = StaticRouter.routeList.filter((route) => route.preload === true);\n        for (const route of filteredRoutes) {\n            route.templatePath && route.templatePath();\n        }\n    }\n}\n","const matchPath = (route, path) => {\n    if (route && path) {\n        const pattern = new RegExp(route.replace(/:[^\\s/]+/g, '(.+)'));\n        return pattern.test(path);\n    }\n    return false;\n};\nexport { matchPath };\n","import { __decorate } from \"tslib\";\nimport { BehaviourSubjectObs, Injectable, SubjectObs, fromEvent, wrapIntoObservable } from '@plumejs/core';\nimport { StaticRouter } from './staticRouter';\nimport { matchPath } from './utils';\nlet InternalRouter = class InternalRouter {\n    _currentRoute = new BehaviourSubjectObs({\n        path: '',\n        routeParams: new Map(),\n        queryParams: new Map(),\n        state: {}\n    });\n    _template = new BehaviourSubjectObs('');\n    _navigationEndEvent = new SubjectObs();\n    _routeStateMap = new Map();\n    listenRouteChanges() {\n        const event = StaticRouter.isHistoryBasedRouting ? 'popstate' : 'hashchange';\n        if (StaticRouter.isHistoryBasedRouting) {\n            window.history.replaceState({}, null, '');\n            (function (history, fn) {\n                const pushState = history.pushState;\n                history.pushState = function (...args) {\n                    pushState.apply(history, args);\n                    fn();\n                };\n            })(window.history, this._registerOnHashChange.bind(this));\n        }\n        return fromEvent(window, event, () => {\n            this._registerOnHashChange();\n        });\n    }\n    getTemplate() {\n        return this._template.asObservable();\n    }\n    getCurrentRoute() {\n        return this._currentRoute.asObservable();\n    }\n    navigateTo(path = '/', state) {\n        let windowPath = StaticRouter.isHistoryBasedRouting\n            ? window.location.pathname\n            : window.location.hash.replace(/^#/, '');\n        windowPath = windowPath ? windowPath : '/';\n        this._routeStateMap.clear();\n        this._routeStateMap.set(path, state);\n        if (windowPath === path) {\n            this._navigateTo(path, state);\n        }\n        else {\n            StaticRouter.isHistoryBasedRouting\n                ? window.history.pushState(state, '', path)\n                : (window.location.hash = '#' + path);\n        }\n    }\n    onNavigationEnd() {\n        return this._navigationEndEvent.asObservable();\n    }\n    _registerOnHashChange() {\n        const path = StaticRouter.isHistoryBasedRouting ? window.location.pathname : window.location.hash.replace(/^#/, '');\n        const state = this._routeStateMap.get(path);\n        this._navigateTo(path, state);\n    }\n    _navigateTo(path, state) {\n        const currentRouteData = {};\n        const uParams = path.split('/').filter((h) => {\n            return h.length > 0;\n        });\n        const routeArr = StaticRouter.routeList.filter((route) => {\n            if (route.params.length === uParams.length && matchPath(route.url, path)) {\n                return route;\n            }\n            else if (route.url === path) {\n                return route;\n            }\n        });\n        const routeItem = routeArr.length > 0 ? routeArr[0] : null;\n        if (routeItem) {\n            currentRouteData.path = path;\n            currentRouteData.state = { ...(state || {}) };\n            wrapIntoObservable(routeItem.canActivate()).subscribe((val) => {\n                if (!val)\n                    return;\n                const _params = StaticRouter.checkParams(uParams, routeItem);\n                if (Object.keys(_params).length > 0 || path) {\n                    currentRouteData.routeParams = new Map(Object.entries(_params));\n                    let entries = [];\n                    if (StaticRouter.isHistoryBasedRouting) {\n                        entries = new URLSearchParams(window.location.search).entries();\n                    }\n                    else {\n                        entries = window.location.hash.split('?')[1]\n                            ? new URLSearchParams(window.location.hash.split('?')[1]).entries()\n                            : [];\n                    }\n                    currentRouteData.queryParams = new Map(entries);\n                    const triggerNavigation = (routeItem) => {\n                        routeItem.isRegistered = true;\n                        this._currentRoute.next(currentRouteData);\n                        this._template.next(routeItem.template);\n                        this._navigationEndEvent.next(null);\n                    };\n                    if (!routeItem.isRegistered) {\n                        if (routeItem.templatePath) {\n                            wrapIntoObservable(routeItem.templatePath()).subscribe(() => {\n                                triggerNavigation(routeItem);\n                            });\n                        }\n                        else if (routeItem.redirectTo) {\n                            this.navigateTo(routeItem.redirectTo, state);\n                        }\n                    }\n                    else {\n                        triggerNavigation(routeItem);\n                    }\n                }\n                else {\n                    this.navigateTo(routeItem.redirectTo, state);\n                }\n            });\n        }\n    }\n};\nInternalRouter = __decorate([\n    Injectable()\n], InternalRouter);\nexport { InternalRouter };\n","import { __decorate, __metadata } from \"tslib\";\nimport { Component, html, Renderer, Subscriptions } from '@plumejs/core';\nimport { InternalRouter } from './internalRouter.service';\nimport { StaticRouter } from './staticRouter';\nlet RouterOutlet = class RouterOutlet {\n    internalRouterSrvc;\n    renderer;\n    _template = '';\n    _subscriptions = new Subscriptions();\n    constructor(internalRouterSrvc, renderer) {\n        this.internalRouterSrvc = internalRouterSrvc;\n        this.renderer = renderer;\n    }\n    beforeMount() {\n        this._subscriptions.add(this.internalRouterSrvc.getTemplate().subscribe((tmpl) => {\n            if (this._template !== tmpl) {\n                this._template = tmpl;\n            }\n        }));\n        this._subscriptions.add(this.internalRouterSrvc.listenRouteChanges());\n    }\n    mount() {\n        const path = StaticRouter.isHistoryBasedRouting ? window.location.pathname : window.location.hash.replace(/^#/, '');\n        this.internalRouterSrvc.navigateTo(path || '/', null);\n    }\n    unmount() {\n        this._subscriptions.unsubscribe();\n    }\n    render() {\n        if (this._template) {\n            const stringArray = [`${this._template}`];\n            stringArray.raw = [`${this._template}`];\n            return html(stringArray);\n        }\n        else {\n            return html ``;\n        }\n    }\n};\nRouterOutlet = __decorate([\n    Component({\n        selector: 'router-outlet',\n        deps: [InternalRouter, Renderer]\n    }),\n    __metadata(\"design:paramtypes\", [InternalRouter, Renderer])\n], RouterOutlet);\n","import { __decorate, __metadata } from \"tslib\";\nimport { Injectable } from '@plumejs/core';\nimport { InternalRouter } from './internalRouter.service';\nimport { StaticRouter } from './staticRouter';\nlet Router = class Router {\n    internalRouter;\n    constructor(internalRouter) {\n        this.internalRouter = internalRouter;\n    }\n    getCurrentRoute() {\n        return this.internalRouter.getCurrentRoute();\n    }\n    navigateTo(path, state) {\n        this.internalRouter.navigateTo(path, state);\n    }\n    onNavigationEnd() {\n        return this.internalRouter.onNavigationEnd();\n    }\n    static registerRoutes({ routes, preloadAllRoutes = false, isHashBasedRouting = false }) {\n        if (isHashBasedRouting) {\n            StaticRouter.isHistoryBasedRouting = !isHashBasedRouting;\n        }\n        if (Array.isArray(routes)) {\n            for (const route of routes) {\n                StaticRouter.formatRoute(route);\n            }\n            if (preloadAllRoutes) {\n                StaticRouter.preloadRoutes();\n            }\n            else {\n                StaticRouter.preloadSelectedRoutes();\n            }\n        }\n        else {\n            throw Error('router.addRoutes: the parameter must be an array');\n        }\n    }\n};\nRouter = __decorate([\n    Injectable({ deps: [InternalRouter] }),\n    __metadata(\"design:paramtypes\", [InternalRouter])\n], Router);\nexport { Router };\n"],"names":["StaticRouter","static","checkParams","urlParams","routeItem","paramMapCount","paramsObject","paramCount","i","length","routeParam","params","indexOf","split","getParamCount","forEach","param","formatRoute","route","internalRouteItem","url","template","isRegistered","redirectTo","preload","canActivate","path","filter","str","templatePath","Error","routeList","push","preloadRoutes","preloadSelectedRoutes","filteredRoutes","matchPath","RegExp","replace","test","InternalRouter","_currentRoute","BehaviourSubjectObs","routeParams","Map","queryParams","state","_template","_navigationEndEvent","SubjectObs","_routeStateMap","listenRouteChanges","event","isHistoryBasedRouting","window","history","replaceState","fn","pushState","args","apply","this","_registerOnHashChange","bind","fromEvent","getTemplate","asObservable","getCurrentRoute","navigateTo","windowPath","location","pathname","hash","clear","set","_navigateTo","onNavigationEnd","get","currentRouteData","uParams","h","routeArr","wrapIntoObservable","subscribe","val","_params","Object","keys","entries","URLSearchParams","search","triggerNavigation","next","Injectable","RouterOutlet","internalRouterSrvc","renderer","_subscriptions","Subscriptions","constructor","beforeMount","add","tmpl","mount","unmount","unsubscribe","render","stringArray","raw","html","Component","selector","deps","Renderer","Router","internalRouter","registerRoutes","routes","preloadAllRoutes","isHashBasedRouting","Array","isArray"],"sourceRoot":""}